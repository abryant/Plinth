package eu.bryants.anthony.plinth.compiler.passes;

import java.util.HashSet;
import java.util.Set;

import eu.bryants.anthony.plinth.ast.LexicalPhrase;
import eu.bryants.anthony.plinth.ast.TypeDefinition;
import eu.bryants.anthony.plinth.ast.member.Constructor;
import eu.bryants.anthony.plinth.ast.member.Field;
import eu.bryants.anthony.plinth.ast.member.Initialiser;
import eu.bryants.anthony.plinth.ast.member.Method;
import eu.bryants.anthony.plinth.ast.member.Property;
import eu.bryants.anthony.plinth.ast.metadata.GlobalVariable;
import eu.bryants.anthony.plinth.compiler.ConceptualException;

/*
 * Created on 6 Jul 2012
 */

/**
 * @author Anthony Bryant
 */
public class NativeNameChecker
{

  private static final Set<String> FORBIDDEN_NAMES = new HashSet<String>();
  static
  {
    FORBIDDEN_NAMES.add("malloc");
    FORBIDDEN_NAMES.add("free");
  }

  private Set<String> usedNativeNames = new HashSet<String>();
  private boolean restrictMainMethod;

  /**
   * Creates a new NativeNameChecker to check for bad native names.
   * @param restrictMainMethod - whether a "main" method is going to be generated by the code generator
   */
  public NativeNameChecker(boolean restrictMainMethod)
  {
    this.restrictMainMethod = restrictMainMethod;
  }

  /**
   * Checks that the specified TypeDefinition does not have any bad (e.g. duplicated) native names.
   * This ensures that the names do not collide during code generation.
   * @param typeDefinition - the TypeDefinition to check the native names of
   * @throws ConceptualException - if a bad native name is found
   */
  public void checkNormalNativeNames(TypeDefinition typeDefinition) throws ConceptualException
  {
    checkName(Initialiser.getMangledName(typeDefinition, true), typeDefinition.getLexicalPhrase());
    checkName(Initialiser.getMangledName(typeDefinition, false), typeDefinition.getLexicalPhrase());
    for (Constructor constructor : typeDefinition.getAllConstructors())
    {
      checkName(constructor.getMangledName(), constructor.getLexicalPhrase());
    }
    for (Field field : typeDefinition.getFields())
    {
      if (!field.isStatic())
      {
        continue;
      }
      GlobalVariable global = field.getGlobalVariable();
      checkName(global.getMangledName(), field.getLexicalPhrase());
    }
    for (Property property : typeDefinition.getProperties())
    {
      if (property.isStatic() && !property.isUnbacked())
      {
        checkName(property.getBackingVariableMangledName(), property.getLexicalPhrase());
      }
      checkName(property.getGetterMangledName(), property.getLexicalPhrase());
      if (!property.isFinal())
      {
        checkName(property.getSetterMangledName(), property.getLexicalPhrase());
      }
      if (property.hasConstructor())
      {
        checkName(property.getConstructorMangledName(), property.getLexicalPhrase());
      }
    }
    for (Method method : typeDefinition.getAllMethods())
    {
      checkName(method.getMangledName(), method.getLexicalPhrase());
    }
  }

  /**
   * Checks that the specified TypeDefinition does not have any bad (e.g. duplicated) user-specified native names.
   * This ensures that the names do not collide during code generation.
   * @param typeDefinition - the TypeDefinition to check the native names of
   * @throws ConceptualException - if a bad native name is found
   */
  public void checkSpecifiedNativeNames(TypeDefinition typeDefinition) throws ConceptualException
  {
    for (Method method : typeDefinition.getAllMethods())
    {
      String nativeName = method.getNativeName();
      if (nativeName != null)
      {
        checkName(nativeName, method.getLexicalPhrase());
      }
    }
  }

  /**
   * Checks whether the specified native name is explicitly forbidden, and if so throws a ConceptualException
   * @param name - the name to check
   * @param lexicalPhrase - the lexical phrase to throw as part of the ConceptualException if the name is forbidden
   * @throws ConceptualException - if the name is forbidden
   */
  private void checkName(String name, LexicalPhrase lexicalPhrase) throws ConceptualException
  {
    boolean newName = usedNativeNames.add(name);
    if (restrictMainMethod && name.equals("main"))
    {
      throw new ConceptualException("Duplicate native name: " + name, lexicalPhrase);
    }
    if (!newName)
    {
      throw new ConceptualException("Duplicate native name: " + name, lexicalPhrase);
    }
    if (FORBIDDEN_NAMES.contains(name) || name.startsWith("llvm."))
    {
      throw new ConceptualException("Forbidden native name: " + name, lexicalPhrase);
    }
  }

}
