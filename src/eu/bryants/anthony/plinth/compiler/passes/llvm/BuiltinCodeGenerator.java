package eu.bryants.anthony.plinth.compiler.passes.llvm;

import nativelib.c.C;
import nativelib.llvm.LLVM;
import nativelib.llvm.LLVM.LLVMBasicBlockRef;
import nativelib.llvm.LLVM.LLVMBuilderRef;
import nativelib.llvm.LLVM.LLVMModuleRef;
import nativelib.llvm.LLVM.LLVMTypeRef;
import nativelib.llvm.LLVM.LLVMValueRef;
import eu.bryants.anthony.plinth.ast.member.BuiltinMethod;
import eu.bryants.anthony.plinth.ast.member.BuiltinMethod.BuiltinMethodType;
import eu.bryants.anthony.plinth.ast.member.Method;
import eu.bryants.anthony.plinth.ast.misc.Parameter;
import eu.bryants.anthony.plinth.ast.type.PrimitiveType;
import eu.bryants.anthony.plinth.ast.type.PrimitiveType.PrimitiveTypeType;
import eu.bryants.anthony.plinth.ast.type.Type;
import eu.bryants.anthony.plinth.compiler.passes.SpecialTypeHandler;

/*
 * Created on 11 Oct 2012
 */

/**
 * @author Anthony Bryant
 */
public class BuiltinCodeGenerator
{
  private LLVMBuilderRef builder;
  private LLVMModuleRef module;

  private CodeGenerator codeGenerator;
  private TypeHelper typeHelper;

  /**
   * Creates a new BuiltinCodeGenerator to generate code for special types.
   * @param builder - the LLVMBuilderRef to build code with
   * @param module - the LLVMModuleRef to add new functions to
   * @param codeGenerator - the CodeGenerator to use to build certain elements of the module
   * @param typeHelper - the TypeHelper to find native types with, and to use to convert between types
   */
  public BuiltinCodeGenerator(LLVMBuilderRef builder, LLVMModuleRef module, CodeGenerator codeGenerator, TypeHelper typeHelper)
  {
    this.builder = builder;
    this.module = module;
    this.codeGenerator = codeGenerator;
    this.typeHelper = typeHelper;
  }

  public LLVMValueRef generateMethod(BuiltinMethod method)
  {
    Type baseType = method.getBaseType();
    BuiltinMethodType builtinType = method.getBuiltinType();
    switch (builtinType)
    {
    case BOOLEAN_TO_STRING:
      return buildBooleanToString((PrimitiveType) baseType, method);
    case SIGNED_TO_STRING:
      return buildSignedToString((PrimitiveType) baseType, method, false);
    case SIGNED_TO_STRING_RADIX:
      return buildSignedToString((PrimitiveType) baseType, method, true);
    case UNSIGNED_TO_STRING:
      return buildUnsignedToString((PrimitiveType) baseType, method, false);
    case UNSIGNED_TO_STRING_RADIX:
      return buildUnsignedToString((PrimitiveType) baseType, method, true);
    case FLOATING_TO_STRING:
      return buildFloatingToString((PrimitiveType) baseType, method);
    default:
      throw new IllegalArgumentException("Unknown special method: " + method);
    }
  }

  private LLVMValueRef getBuiltinMethod(BuiltinMethod method)
  {
    Type baseType = method.getBaseType();
    String nativeName = method.getMangledName();

    Parameter[] parameters = method.getParameters();
    LLVMTypeRef[] types = new LLVMTypeRef[1 + parameters.length];
    // add the 'this' type to the function - 'this' always has a temporary type representation
    if (method.isStatic())
    {
      // for static methods, we add an unused opaque*, so that the static method can be easily converted to a function type
      types[0] = typeHelper.getOpaquePointer();
    }
    else
    {
      types[0] = typeHelper.findTemporaryType(baseType);
    }
    for (int i = 0; i < parameters.length; ++i)
    {
      types[i + 1] = typeHelper.findStandardType(parameters[i].getType());
    }
    LLVMTypeRef resultType = typeHelper.findStandardType(method.getReturnType());

    LLVMTypeRef functionType = LLVM.LLVMFunctionType(resultType, C.toNativePointerArray(types, false, true), types.length, false);
    LLVMValueRef llvmFunc = LLVM.LLVMAddFunction(module, nativeName, functionType);
    LLVM.LLVMSetFunctionCallConv(llvmFunc, LLVM.LLVMCallConv.LLVMCCallConv);
    // use private linkage, so that this function does not conflict with anything
    // by doing this, we ensure that linking with modules generated by a newer BuiltinCodeGenerator do not clash with this definition and cause problems
    LLVM.LLVMSetLinkage(llvmFunc, LLVM.LLVMLinkage.LLVMPrivateLinkage);

    int paramCount = LLVM.LLVMCountParams(llvmFunc);
    if (paramCount != types.length)
    {
      throw new IllegalStateException("LLVM returned wrong number of parameters");
    }
    LLVM.LLVMSetValueName(LLVM.LLVMGetParam(llvmFunc, 0), method.isStatic() ? "unused" : "this");
    for (int i = 0; i < parameters.length; ++i)
    {
      LLVMValueRef parameter = LLVM.LLVMGetParam(llvmFunc, i + 1);
      LLVM.LLVMSetValueName(parameter, parameters[i].getName());
    }

    return llvmFunc;
  }

  private LLVMValueRef buildBooleanToString(PrimitiveType baseType, BuiltinMethod method)
  {
    if (baseType.getPrimitiveTypeType() != PrimitiveTypeType.BOOLEAN)
    {
      throw new IllegalArgumentException("A builtin boolean toString function must have the correct base type");
    }

    LLVMValueRef builtinFunction = getBuiltinMethod(method);
    LLVMValueRef valueOfFunction = codeGenerator.getMethodFunction(null, SpecialTypeHandler.stringValueOfBoolean);

    LLVMBasicBlockRef entryBlock = LLVM.LLVMAppendBasicBlock(builtinFunction, "entry");
    LLVM.LLVMPositionBuilderAtEnd(builder, entryBlock);
    LLVMValueRef parameter = LLVM.LLVMGetParam(builtinFunction, 0);
    LLVMValueRef[] arguments = new LLVMValueRef[] {LLVM.LLVMConstNull(typeHelper.getOpaquePointer()), parameter};
    LLVMValueRef result = LLVM.LLVMBuildCall(builder, valueOfFunction, C.toNativePointerArray(arguments, false, true), arguments.length, "");
    LLVM.LLVMBuildRet(builder, result);

    return builtinFunction;
  }

  private LLVMValueRef buildSignedToString(PrimitiveType baseType, BuiltinMethod method, boolean radix)
  {
    if (baseType.getPrimitiveTypeType() != PrimitiveTypeType.BYTE &&
        baseType.getPrimitiveTypeType() != PrimitiveTypeType.SHORT &&
        baseType.getPrimitiveTypeType() != PrimitiveTypeType.INT &&
        baseType.getPrimitiveTypeType() != PrimitiveTypeType.LONG)
    {
      throw new IllegalArgumentException("A builtin signed toString function must have the correct base type");
    }

    LLVMValueRef builtinFunction = getBuiltinMethod(method);
    Method valueOfMethod = radix ? SpecialTypeHandler.stringValueOfLongRadix : SpecialTypeHandler.stringValueOfLong;
    LLVMValueRef valueOfFunction = codeGenerator.getMethodFunction(null, valueOfMethod);

    LLVMBasicBlockRef entryBlock = LLVM.LLVMAppendBasicBlock(builtinFunction, "entry");
    LLVM.LLVMPositionBuilderAtEnd(builder, entryBlock);

    // get the parameter and convert it to a long
    LLVMValueRef parameter = LLVM.LLVMGetParam(builtinFunction, 0);
    parameter = typeHelper.convertTemporary(parameter, baseType, valueOfMethod.getParameters()[0].getType());

    LLVMValueRef[] arguments;
    if (radix)
    {
      LLVMValueRef radixParam = LLVM.LLVMGetParam(builtinFunction, 1);
      arguments = new LLVMValueRef[] {LLVM.LLVMConstNull(typeHelper.getOpaquePointer()), parameter, radixParam};
    }
    else
    {
      arguments = new LLVMValueRef[] {LLVM.LLVMConstNull(typeHelper.getOpaquePointer()), parameter};
    }
    LLVMValueRef result = LLVM.LLVMBuildCall(builder, valueOfFunction, C.toNativePointerArray(arguments, false, true), arguments.length, "");
    LLVM.LLVMBuildRet(builder, result);

    return builtinFunction;
  }

  private LLVMValueRef buildUnsignedToString(PrimitiveType baseType, BuiltinMethod method, boolean radix)
  {
    if (baseType.getPrimitiveTypeType() != PrimitiveTypeType.UBYTE &&
        baseType.getPrimitiveTypeType() != PrimitiveTypeType.USHORT &&
        baseType.getPrimitiveTypeType() != PrimitiveTypeType.UINT &&
        baseType.getPrimitiveTypeType() != PrimitiveTypeType.ULONG)
    {
      throw new IllegalArgumentException("A builtin unsigned toString function must have the correct base type");
    }

    LLVMValueRef builtinFunction = getBuiltinMethod(method);
    Method valueOfMethod = radix ? SpecialTypeHandler.stringValueOfUlongRadix : SpecialTypeHandler.stringValueOfUlong;
    LLVMValueRef valueOfFunction = codeGenerator.getMethodFunction(null, valueOfMethod);

    LLVMBasicBlockRef entryBlock = LLVM.LLVMAppendBasicBlock(builtinFunction, "entry");
    LLVM.LLVMPositionBuilderAtEnd(builder, entryBlock);

    // get the parameter and convert it to a long
    LLVMValueRef parameter = LLVM.LLVMGetParam(builtinFunction, 0);
    parameter = typeHelper.convertTemporary(parameter, baseType, valueOfMethod.getParameters()[0].getType());

    LLVMValueRef[] arguments;
    if (radix)
    {
      LLVMValueRef radixParam = LLVM.LLVMGetParam(builtinFunction, 1);
      arguments = new LLVMValueRef[] {LLVM.LLVMConstNull(typeHelper.getOpaquePointer()), parameter, radixParam};
    }
    else
    {
      arguments = new LLVMValueRef[] {LLVM.LLVMConstNull(typeHelper.getOpaquePointer()), parameter};
    }
    LLVMValueRef result = LLVM.LLVMBuildCall(builder, valueOfFunction, C.toNativePointerArray(arguments, false, true), arguments.length, "");
    LLVM.LLVMBuildRet(builder, result);

    return builtinFunction;
  }

  private LLVMValueRef buildFloatingToString(PrimitiveType baseType, BuiltinMethod method)
  {
    if (baseType.getPrimitiveTypeType() != PrimitiveTypeType.FLOAT &&
        baseType.getPrimitiveTypeType() != PrimitiveTypeType.DOUBLE)
    {
      throw new IllegalArgumentException("A builtin floating toString function must have the correct base type");
    }

    LLVMValueRef builtinFunction = getBuiltinMethod(method);
    Method valueOfMethod = baseType.getPrimitiveTypeType() == PrimitiveTypeType.FLOAT ? SpecialTypeHandler.stringValueOfFloat : SpecialTypeHandler.stringValueOfDouble;
    LLVMValueRef valueOfFunction = codeGenerator.getMethodFunction(null, valueOfMethod);

    LLVMBasicBlockRef entryBlock = LLVM.LLVMAppendBasicBlock(builtinFunction, "entry");
    LLVM.LLVMPositionBuilderAtEnd(builder, entryBlock);
    LLVMValueRef parameter = LLVM.LLVMGetParam(builtinFunction, 0);
    LLVMValueRef[] arguments = new LLVMValueRef[] {LLVM.LLVMConstNull(typeHelper.getOpaquePointer()), parameter};
    LLVMValueRef result = LLVM.LLVMBuildCall(builder, valueOfFunction, C.toNativePointerArray(arguments, false, true), arguments.length, "");
    LLVM.LLVMBuildRet(builder, result);

    return builtinFunction;
  }
}
