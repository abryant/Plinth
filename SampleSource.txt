package foo.bar;

import test.*;

compound complex
{
  static
  {
    uint x = 2;
    ++x;
  }

  {
    o = null;
  }

  double real = 1;
  double imag = 0;
  ?other o;

  complex()
  {
  }

  complex(double real, double imag)
  {
    this.real, this.imag = real, imag;
    o = other(cast<uint> imag);
  }

  complex mult(complex c)
  {
    return complex(real * c.real - imag * c.imag, real * c.imag + imag * c.real);
  }

  static native uint main(final uint argc)
  {
    ?(uint, ?complex) t = 18, complex(argc, 2);
    Asdf yes = new Asdf(1);
    ?Asdf no = null;
    if yes == no
    {
      return 249;
    }
    complex c = (t ?: (5, complex()))!2 ?: complex();
    complex result = Asdf::rotateComplexLeft(c);
    (result.o ?: other(123)).modify();
    return (result.o ?: other(123)).getX();
  }
}

compound other
{
  uint x;
  double y;

  other(uint x)
  {
    this.x, y = x, x;
  }

  uint getX()
  {
    return x;
  }

  void modify()
  {
    ++x;
    ++y;
  }
}
