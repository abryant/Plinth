package foo.bar;

import test.asdf;

compound complex
{
  static ? :complex asdf;
  static ?(:complex, uint, ?[]float) test;
  final double real;
  final double imag;
  complex()
  {
    real, imag = 0, 0;
  }
  complex(double real, double imag)
  {
    this.real, this.imag = real, imag;
  }
  complex(double real)
  {
    this.real, this.imag = real, 0;
  }
  double getReal()
  {
    return real;
  }
  double getImag()
  {
    return imag;
  }
  :complex mult(:complex other)
  {
    return complex(real * other.real - imag * other.imag, real * other.imag + other.real * imag);
  }
  :complex add(:complex other)
  {
    return complex(real + other.real, imag + other.imag);
  }
  :complex subtract(:complex other)
  {
    asdf = complex(1, 2);
    return complex(real - other.real, imag - other.imag);
  }
  static :complex rotateLeft(:complex value)
  {
    asdf = value.mult(complex(0, 1));
    return cast<:complex> asdf;
  }
  static :complex swap(:complex initial)
  {
    return complex(initial.imag, initial.real);
  }

  static native uint main(final uint argc)
  {
    final int x;
    if argc < 2
    {
      x = 1;
    }
    else
    {
      x = 2;
    }
    ?uint a = true ? null : 5;
    ?[](?uint, int) arr = new [](?uint, int) {(argc, 2), (8, -4), (null, 2)};

    final uint f = (cast<?ubyte> a) ?: 5;

    return (cast<[](?uint, int)> arr)[2]!1 ?: (cast<[](?uint, int)> arr)[0]!1 ?: 34;
  }
}
