compound foo
{
  uint someField;
  foo(uint someField)
  {
    someField = someField+2;
    this.someField = someField;
    accessField(this);
  }
  void test(uint a)
  {
    someField = a;
  }
}

uint main(uint argc)
{
  for (uint i;false;)
  {
  }

  []uint array = new []uint {0, 1, 2, 3};
  --argc;
  if (argc > 2)
  {
    reverse(array);
  }
  uint foo = 4 * (4 * (4 * array[0] + array[1]) + array[2]) + array[3];

  :foo test = foo(2);
  test.someField = 67;

  []uint temp = new [1]uint;
  []long arr = new [2]long;
  // should put 27 in temp[0], due to the order of evaluation of the function calls in an array assignment
  array(arr, temp)[dimension(temp)] = value(temp);
  return test.someField + ((temp[0] ^ foo) == 0 ? 5 : 13);
  
}

void accessField(:foo p)
{
  uint f = p.someField;
}

:foo doStuff((:foo, short) param)
{
  _,_ = param;
  return foo(5);
}

[]long array([]long arr, []uint temp)
{
  temp[0] = 4 * temp[0] + 1;
  return arr;
}

uint dimension([]uint temp)
{
  temp[0] = 4 * temp[0] + 2;
  return 0;
}
long value([]uint temp)
{
  temp[0] = (temp[0] << 2) + 3;
  return 123;
}

void reverse([]uint arr)
{
  uint i = 0;
  while (i < arr.length / 2)
  {
    arr[i], arr[arr.length - 1 - i] = arr[arr.length - 1 - i], arr[i];
    i = i + 1;
  }
}
