package foo.bar;

import test.*;

compound complex
{
  static final uint test;
  static
  {
    uint x = 2;
    ++x;
    x += test;
    complex::test = 6;
  }

  {
    o = null;
  }

  double real = 1;
  double imag = 0;
  ?Other o;

  complex()
  {
  }

  complex(double real, double imag)
  {
    this.real, this.imag = real, imag;
    o = new Other(cast<uint> imag);
  }

  complex mult(complex c)
  {
    return complex(real * c.real - imag * c.imag, real * c.imag + imag * c.real);
  }

  static native uint main(final uint argc)
  {
    Other other = new Other(test);
    []uint values = new []uint {1, 2, 3, 4, 5, argc};
    []?uint mapped = map(other.add, values);
    multiply(2);
    return complex().apply(multiply, (mapped[5] ?: 0) - 1);
  }

  static []?uint map({uint -> uint} f, []uint arg)
  {
    []?uint result = new [arg.length]?uint;
    for (uint i = 0; i < arg.length; ++i)
    {
      result[i] = f(arg[i]);
    }
    return result;
  }

  uint apply({uint -> uint} f, uint arg)
  {
    return f(arg);
  }

  static uint multiply(uint x)
  {
    return x * 2;
  }
}

class Other
{
  uint x;
  double y;

  Other(uint x)
  {
    this.x, y = x, x;
  }

  uint getX()
  {
    return x;
  }

  void modify()
  {
    ++x;
    ++y;
  }

  uint add(uint x)
  {
    return x + this.x;
  }
}
