package foo.bar;

import test.*;

compound complex
{
  static final uint test;
  static
  {
    uint x = 2;
    ++x;
    x += test;
    complex::test = 6;
  }

  {
    o = null;
  }

  double real = 1;
  double imag = 0;
  ?Other o;

  complex()
  {
  }

  complex(double real, double imag)
  {
    this.real, this.imag = real, imag;
    o = new Other(cast<uint> imag);
  }

  complex mult(complex c)
  {
    return complex(real * c.real - imag * c.imag, real * c.imag + imag * c.real);
  }

  static native uint main(final uint argc)
  {
    ?complex x = complex();
    x?.doStuff();
    ?Other other = new Other(argc);
    ?{uint -> uint} f = other?.add;
    {uint -> uint} f2 = f ?: multiply;
    return complex().apply(f2, 1);
  }

  static []?uint map({uint -> uint} f, []uint arg)
  {
    []?uint result = new [arg.length]?uint;
    for (uint i = 0; i < arg.length; ++i)
    {
      result[i] = f(arg[i]);
    }
    return result;
  }

  uint apply({uint -> uint} f, uint arg)
  {
    return f(arg);
  }

  void doStuff()
  {
    // in this context, "Stuff" means "Nothing"
  }

  static uint multiply(uint x)
  {
    return x * 2;
  }
}

class Other
{
  uint x;
  double y;

  Other(uint x)
  {
    this.x, y = x, x;
  }

  uint getX()
  {
    return x;
  }

  void modify()
  {
    ++x;
    ++y;
  }

  uint add(uint x)
  {
    return x + this.x;
  }
}
