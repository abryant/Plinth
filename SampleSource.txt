package foo.bar;

import test.*;

compound complex
{
  static final uint test;
  static
  {
    uint x = 2;
    ++x;
    x += test;
    complex::test = 6;
  }

  double real;
  double imag;

  complex()
  {
  }

  complex(double real, double imag)
  {
    this.real, this.imag = real, imag;
  }

  complex mult(complex c)
  {
    return complex(real * c.real - imag * c.imag, real * c.imag + imag * c.real);
  }

  static native uint main(final uint argc)
  {
    ?complex x = complex();
    x?.doStuff();
    ?Other other = null;
    ?{uint -> uint} f = other?.add;
    {uint -> uint} f2 = f ?: multiply;
    []uint arr = new []uint {1, 2, argc};
    return map(f2, arr)[2];
  }

  static []uint map({uint -> uint} f, []uint input)
  {
    []uint result = new [input.length]uint;
    for (uint i = 0; i < input.length; ++i)
    {
      result[i] = f(input[i]);
    }
    return result;
  }

  uint apply({uint -> uint} f, uint arg)
  {
    return f(arg);
  }

  void doStuff()
  {
    // in this context, "Stuff" means "Nothing"
  }

  static uint multiply(uint x)
  {
    return x * 2;
  }
}

class Other
{
  uint x;
  double y;

  Other(uint x)
  {
    this.x, y = x, x;
  }

  uint getX()
  {
    return x;
  }

  void modify()
  {
    ++x;
    ++y;
  }

  uint add(uint x)
  {
    return x + this.x;
  }
}
