package foo.bar;

import test.*;

compound complex
{
  final double real;
  final double imag;

  complex()
  {
    real, imag = 0, 0;
  }
  
  complex(double real, double imag)
  {
    this.real, this.imag = real, imag;
  }

  :complex mult(:complex c)
  {
    return complex(real * c.real - imag * c.imag, real * c.imag + imag * c.real);
  }

  static native uint main(final uint argc)
  {
    // TODO: fix the low level representation of nullable compound types
    // in particular type conversions should not be able to copy the compound type,
    // so converting a 'complex' to a '?complex' should not cause functions called on it to not have side effects
    // this should be done as a revamp of the code generator's native type system
    :Asdf yes = new Asdf(1);
    ? :Asdf no = null;
    if yes == no
    {
      return 249;
    }
    :complex c = complex(argc, 0);
    :complex result = :Asdf::rotateComplexLeft(c);
    return cast<uint> result.imag;
  }
}
